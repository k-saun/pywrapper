<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Python.EmbeddingTest</name>
    </assembly>
    <members>
        <member name="M:Python.EmbeddingTest.DynamicTest.AssignObject">
            <summary>
            Set the attribute of a PyObject with a .NET object.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.DynamicTest.AssignNone">
            <summary>
            Set the attribute of a PyObject to null.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.DynamicTest.AssignPyObject">
            <summary>
            Check whether we can get the attr of a python object when the
            value of attr is a PyObject.
            </summary>
            <remarks>
            FIXME: Issue on Travis PY27: Error : Python.EmbeddingTest.dynamicTest.AssignPyObject
            Python.Runtime.PythonException : ImportError : /home/travis/virtualenv/python2.7.9/lib/python2.7/lib-dynload/_io.so: undefined symbol: _PyLong_AsInt
            </remarks>
        </member>
        <member name="M:Python.EmbeddingTest.DynamicTest.PassObjectInPython">
            <summary>
            Pass the .NET object in Python side.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.DynamicTest.PassPyObjectInNet">
            <summary>
            Pass the PyObject in .NET side
            </summary>
        </member>
        <member name="T:Python.EmbeddingTest.PyImportTest">
            <summary>
            Test Import unittests and regressions
            </summary>
            <remarks>
            Keeping in old-style SetUp/TearDown due to required SetUp.
            The required directory structure was added to .\pythonnet\src\embed_tests\fixtures\ directory:
            + PyImportTest/
            | - __init__.py
            | + test/
            | | - __init__.py
            | | - one.py
            </remarks>
        </member>
        <member name="M:Python.EmbeddingTest.PyImportTest.TestDottedName">
            <summary>
            Test subdirectory import
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyImportTest.TestSysArgsImportException">
            <summary>
            Tests that sys.args is set. If it wasn't exception would be raised.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyImportTest.TestCastGlobalVar">
            <summary>
            Test Global Variable casting. GH#420
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyInitializeTest.StartAndStopTwice">
            <summary>
            Tests issue with multiple simple Initialize/Shutdowns.
            Fixed by #343
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyInitializeTest.ReInitialize">
            <summary>
            Failing test demonstrating current issue with OverflowException (#376)
            and ArgumentException issue after that one is fixed.
            More complex version of StartAndStopTwice test
            </summary>
        </member>
        <member name="F:Python.EmbeddingTest.PyInitializeTest.shutdown_count">
            <summary>
            Helper for testing the shutdown handlers.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyInitializeTest.ShutdownHandlers">
            <summary>
            Test the shutdown handlers.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.TestDomainReload.DomainReloadAndGC">
             <summary>
             Test that the python runtime can survive a C# domain reload without crashing.
            
             At the time this test was written, there was a very annoying
             seemingly random crash bug when integrating pythonnet into Unity.
            
             The repro steps that David Lassonde, Viktoria Kovecses and
             Benoit Hudson eventually worked out:
             1. Write a HelloWorld.cs script that uses Python.Runtime to access
                 some C# data from python: C# calls python, which calls C#.
             2. Execute the script (e.g. make it a MenuItem and click it).
             3. Touch HelloWorld.cs on disk, forcing Unity to recompile scripts.
             4. Wait several seconds for Unity to be done recompiling and
                 reloading the C# domain.
             5. Make python run the gc (e.g. by calling gc.collect()).
            
             The reason:
             A. In step 2, Python.Runtime registers a bunch of new types with
                 their tp_traverse slot pointing to managed code, and allocates
                 some objects of those types.
             B. In step 4, Unity unloads the C# domain. That frees the managed
                 code. But at the time of the crash investigation, pythonnet
                 leaked the python side of the objects allocated in step 1.
             C. In step 5, python sees some pythonnet objects in its gc list of
                 potentially-leaked objects. It calls tp_traverse on those objects.
                 But tp_traverse was freed in step 3 => CRASH.
            
             This test distills what's going on without needing Unity around (we'd see
             similar behaviour if we were using pythonnet on a .NET web server that did
             a hot reload).
             </summary>
        </member>
        <member name="M:Python.EmbeddingTest.TestDomainReload.BuildAssembly(System.String)">
             <summary>
             Build an assembly out of the source code above.
            
             This creates a file <paramref name="assemblyName"/>.dll in order
             to support the statement "proxy.theAssembly = assembly" below.
             That statement needs a file, can't run via memory.
             </summary>
        </member>
        <member name="T:Python.EmbeddingTest.TestDomainReload.Proxy">
            <summary>
            This is a magic incantation required to run code in an application
            domain other than the current one.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.TestDomainReload.RunAssemblyAndUnload(System.Reflection.Assembly,System.String)">
            <summary>
            Create a domain, run the assembly in it (the RunPython function),
            and unload the domain.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.TestDomainReload.ResolveAssembly(System.Object,System.ResolveEventArgs)">
            <summary>
            Resolves the assembly. Why doesn't this just work normally?
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.TestFinalizer.SimpleTestMemory">
            <summary>
            Because of two vms both have their memory manager,
            this test only prove the finalizer has take effect.
            </summary>
        </member>
        <member name="T:Python.EmbeddingTest.TestPyFloat">
            <remarks>
            PyFloat implementation isn't complete, thus tests aren't complete.
            </remarks>
        </member>
        <member name="M:Python.EmbeddingTest.TestPythonEngineProperties.GetPythonHomeDefault">
            <summary>
            Test default behavior of PYTHONHOME. If ENVVAR is set it will
            return the same value. If not, returns EmptyString.
            </summary>
            <remarks>
            AppVeyor.yml has been update to tests with ENVVAR set.
            </remarks>
        </member>
        <member name="M:Python.EmbeddingTest.TestPyTuple.TestStringIsTupleType">
            <summary>
            Test IsTupleType without having to Initialize a tuple.
            PyTuple constructor use IsTupleType. This decouples the tests.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.TestPyTuple.TestPyTupleIsTupleType">
            <summary>
            Test IsTupleType with Tuple.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.TestPyTuple.TestPyTupleInvalidAppend">
            <summary>
            Test PyTuple.Concat(...) doesn't let invalid appends happen
            and throws and exception.
            </summary>
            <remarks>
            Test has second purpose. Currently it generated an Exception
            that the GC failed to remove often and caused AppDomain unload
            errors at the end of tests. See GH#397 for more info.
            <para />
            Curious, on PY27 it gets a Unicode on the ex.Message. On PY3+ its string.
            </remarks>
        </member>
        <member name="M:Python.EmbeddingTest.TestPyTuple.TestInvalidAsTuple">
            <remarks>
            TODO: Should this throw ArgumentError instead?
            </remarks>
        </member>
        <member name="M:Python.EmbeddingTest.TestNamedArguments.TestKeywordArgs">
            <summary>
            Test named arguments support through Py.kw method
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.TestNamedArguments.TestNamedArgs">
            <summary>
            Test keyword arguments with .net named arguments
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.TestPyWith.TestWithPositive">
            <summary>
            Test that exception is raised in context manager that ignores it.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.TestPyWith.TestWithNegative">
            <summary>
            Test that exception is not raised in context manager that handles it
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.TestRuntime.PlatformCache">
             <summary>
             Test the cache of the information from the platform module.
            
             Test fails on platforms we haven't implemented yet.
             </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyScopeTest.TestEval">
            <summary>
            Eval a Python expression and obtain its return value.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyScopeTest.TestExec">
            <summary>
            Exec Python statements and obtain the variables created.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyScopeTest.TestCompileExpression">
            <summary>
            Compile an expression into an ast object;
            Execute the ast and obtain its return value.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyScopeTest.TestCompileStatements">
            <summary>
            Compile Python statements into an ast object;
            Execute the ast;
            Obtain the local variables created.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyScopeTest.TestScopeFunction">
            <summary>
            Create a function in the scope, then the function can read variables in the scope.
            It cannot write the variables unless it uses the 'global' keyword.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyScopeTest.TestScopeClass">
            <summary>
            Create a class in the scope, the class can read variables in the scope.
            Its methods can write the variables with the help of 'global' keyword.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyScopeTest.TestImportModule">
            <summary>
            Import a python module into the session.
            Equivalent to the Python "import" statement.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyScopeTest.TestImportScope">
            <summary>
            Create a scope and import variables from a scope, 
            exec Python statements in the scope then discard it.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyScopeTest.TestImportAllFromScope">
            <summary>
            Create a scope and import variables from a scope, 
            exec Python statements in the scope then discard it.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyScopeTest.TestImportScopeFunction">
            <summary>
            Create a scope and import variables from a scope, 
            call the function imported.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyScopeTest.TestImportScopeByName">
            <summary>
            Import a python module into the session with a new name.
            Equivalent to the Python "import .. as .." statement.
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyScopeTest.TestVariables">
            <summary>
            Use the locals() and globals() method just like in python module
            </summary>
        </member>
        <member name="M:Python.EmbeddingTest.PyScopeTest.TestThread">
            <summary>
            Share a pyscope by multiple threads.
            </summary>
        </member>
    </members>
</doc>
